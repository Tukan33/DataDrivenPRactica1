---
title: "Practica 1"
author: "Ulises"
output: html_document
date: "2026-01-17"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F)
knitr::opts_chunk$set(warning = F)
knitr::opts_chunk$set(error = F)
knitr::opts_chunk$set(message = F)
```


# Practica 1


## Pregunta 1

De las siguientes preguntas, clasifica cada una como descriptiva, exploratoria, inferencia, predictiva o causal, y razona brevemente (una frase) el porqué:

1. Dado un registro de vehículos que circulan por una autopista, disponemos de su marca y modelo, país de matriculación, y tipo de vehículo (por número de ruedas). Con tal de ajustar precios de los peajes, ¿Cuántos vehículos tenemos por tipo? ¿Cuál es el tipo más frecuente? ¿De qué países tenemos más vehículos?

```
En los tres casos son descriptivas, ya que las preguntas se limitan a resumir el dataset observado (registro de vehículos) mediante ordenaciones o frecuencias.
```

2. Dado un registro de visualizaciones de un servicio de video-on-demand, donde disponemos de los datos del usuario, de la película seleccionada, fecha de visualización y categoría de la película, queremos saber ¿Hay alguna preferencia en cuanto a género literario según los usuarios y su rango de edad?

```
Es exploratoria, ya que intenta identificar patrones entre variables (preferencia de género respecto a la edad)
```

3. Dado un registro de peticiones a un sitio web, vemos que las peticiones que provienen de una red de telefonía concreta acostumbran a ser incorrectas y provocarnos errores de servicio. ¿Podemos determinar si en el futuro, los próximos mensajes de esa red seguirán dando problemas? ¿Hemos notado el mismo efecto en otras redes de telefonía?

```
La primera pregunta es predictiva, ya que intenta predecir si ocurrirán peticiones futuras basándose en el historial.
La segunda pregunta es exploratoria, ya que se compara con otras redes de telefonía
```

4. Dado los registros de usuarios de un servicio de compras por internet, los usuarios pueden agruparse por preferencias de productos comprados. Queremos saber si ¿Es posible que, dado un usuario al azar y según su historial, pueda ser directamente asignado a un o diversos grupos?

```         
Predictiva, porque asigna o clasifica a un usuario nuevo a uno o varios grupos en función de su historial.
```



## Pregunta 2

Considera el siguiente escenario:<br>
Sabemos que un usuario de nuestra red empresarial ha estado usando esta para fines no relacionados con el trabajo, como por ejemplo tener un servicio web no autorizado abierto a la red (otros usuarios tienen servicios web activados y autorizados). No queremos tener que rastrear los puertos de cada PC, y sabemos que la actividad puede haber cesado. Pero podemos acceder a los registros de conexiones TCP de cada máquina de cada trabajador (hacia donde abre conexión un PC concreto). Sabemos que nuestros clientes se conectan desde lugares remotos de forma legítima, como parte de nuestro negocio, y que un trabajador puede haber habilitado temporalmente servicios de prueba. Nuestro objetivo es reducir lo posible la lista de posibles culpables, con tal de explicarles que por favor no expongan nuestros sistemas sin permiso de los operadores o la dirección.

Explica con detalle cómo se podría proceder al análisis y resolución del problema mediante Data Science, indicando de donde se obtendrían los datos, qué tratamiento deberían recibir, qué preguntas hacerse para resolver el problema, qué datos y gráficos se obtendrían, y cómo se comunicarían estos.


```
La forma de abordar el problema con Data Science, usando solo registros de conexiones TCP salientes, es partir de la idea de que si muchos PCs abren conexiones hacia un mismo destino interno (IP:puerto), ese destino probablemente estaba ofreciendo un servicio (aunque ya haya cesado). 

Para ello, se recogen los logs de conexiones TCP por máquina y se enriquecen con fuentes de contexto. Luego se normalizan y limpian los datos (timestamps, duplicación, ...) y se formulan preguntas orientadas a acotar sospechosos: 

- qué hosts internos aparecen como “receptores” con mayor numero de sources
- en qué puertos típicos de servicios web ocurre (80/443/8080/8443/8000, etc.)
- cuáles no están autorizados
- si el patrón es sostenido o puntual

El resultado se presenta como un ranking de candidatos host:puerto no autorizados con métricas explicables (número de fuentes únicas, número de conexiones, duración temporal, distribución horaria) y un “score” simple de probabilidad de servicio, apoyado por gráficos básicos como barras, series temporales y un heatmap. 

Finalmente, se comunica entregando una lista corta y defendible de posibles responsables con evidencia objetiva (qué ocurrió y cuándo) para pedir que no se expongan servicios sin autorización.
```

## **Ejercicio Práctico**
El segundo apartado de la práctica consiste en el análisis de un fichero de registro de peticiones HTTP, que debéis descargar el fichero adjunto: epa-http.zip, cargar en R, y realizar un análisis

Se recomienda tener cierto nivel de familiaridad y al alcance los cheatsheet de las distintas librerías mencionadas en las sesiones de teoría para un análisis más fácil:

- readr
- stringr

Alternativamente, recordad que podéis consultar la sección de ayuda de RStudio y buscar en la documentación los parámetros, así como ejemplos de uso (al final de cada página de documentación) para las funciones (escribiendo ?<nombre-funcion> o presionando F1 sobre el nombre de la función.

Para las siguientes preguntas se requiere usar R. Indica en este documento para cada pregunta el resultado obtenido, describiendo a grandes rasgos el procedimiento seguido para la obtención de la respuesta, justificando cada decisión tomada a la hora de manipular los datos (descartar, agrupar, transformar, etc).

Asegúrate de entregar también el código en un fichero aparte, para poder ejecutarse directamente en un terminal limpio de R.

```{r carga_de_librerías}
library(readr)
library(dplyr)
library(stringr)
```

Cargo y limpio los datos, indicando su tipo en cada campo:

- Con 'stringr' limpio el símbolo " al inicio de cada valor del campo Tipo y el símbolo " que del final de cada valor del campo Protocolo.

- ResponseCode lo modifico al tipo de dato factor, porque son etiquetas

- Bytes lo cambio al tipo de dato integer, para tratarlo como valor numérico

```{r carga_de_datos}
epa_http <- read_table("epa-http.csv", col_names = FALSE, show_col_types = F)
colnames(epa_http) <- c("IP", "Timestamp", "Tipo", "URL", "Protocolo", "ResponseCode", "Bytes")

# Cambio ResponseCode a factor 
epa_http$ResponseCode <- as.factor(epa_http$ResponseCode)

# Cambio Bytes a integer
epa_http$Bytes <- as.integer(epa_http$Bytes)

# Aplicación de stringr en Tipo
epa_http$Tipo <- str_remove(epa_http$Tipo, '^"')

# Aplicación de stringr en Protocolo
epa_http$Protocolo <- str_remove(epa_http$Protocolo, '"$')
```


```{r mostrar_datos, comment = NA}
knitr::kable(
  head(epa_http),
  caption = "Muestra de conjunto de datos:"
)
```

### **Práctica: Pregunta 1**
**Una vez cargado el Dataset a analizar, comprobando que se cargan las IPs, el Timestamp, la Petición (Tipo, URL y Protocolo), Código de respuesta, y Bytes de reply.**

1. Cuales son las dimensiones del dataset cargado (número de filas y columnas)

Número filas:
```{r Pregunta1.1, comment = NA}
cat(nrow(epa_http))
```

Número columnas:  
```{r Pregunta1.2, comment = NA}
cat(ncol(epa_http))
```

2. Valor medio de la columna Bytes
```{r Pregunta1.3, comment = NA}
cat(mean(epa_http$Bytes, na.rm = T))
```


### **Pregunta 2**
**De las diferentes IPs de origen accediendo al servidor, ¿cuantas pertenecen a una IP claramente educativa (que contenga ".edu")?**

```{r Pregunta2, comment = NA}
cat(sum(grepl(".edu", epa_http$IP)))

```

Justificación: Utilizamos *grepl* para filtrar peticiones que contengan ".edu" en el campo IP, obtenemos el total de peticiones que cumplen este filtro.





```{r llegir_data}
epa_http <- read_table("epa-http.csv", col_names = FALSE)
```

You can also embed plots, for example:

```{r pressure, echo=TRUE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

### Pregunta 1
Cuales son las dimensiones del dataset cargado (número de filas y columnas)

```{r p1, echo=FALSE}
dim(epa_http)
```